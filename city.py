# -*- coding: utf-8 -*-
"""Bhopal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SnHWbKFuqAJB-wOU73aI6RvYPIo5tacy
"""

# Commented out IPython magic to ensure Python compatibility.
from IPython.display import display
import pandas as pd

# Displaying data in sumarized way
def display_data(dataframe):
    display(dataframe.head())
    print('...')
    display(dataframe.tail())
    print("DataFrame shape: {}".format(dataframe.shape))

# Loading data from Excel file
#df = pd.read_excel('TierVgMay2020.xlsx')
#df = pd.read_excel('dataTierBH.xlsx')
#df = pd.read_excel('1TierBH.xlsx')
#df = pd.read_excel('dataTierAM.xlsx')
#df = pd.read_excel('TierLU.xlsx')
#df = pd.read_excel('1TierAg.xlsx')
df = pd.read_excel('1TierVg.xlsx')
display_data(df)


print("yes")

display(df.describe(include='all'))



# Printing Unique values in Time, Date, Day and H&R Status
print('Before:', df['Day'].unique())

# Replacing 9 in Day and Vacation because are in the same row with Unknown in Category2
df.loc[df.Day == 9, 'Day'] = df['Day'].mode()[0]
df.loc[df.Vacation == 9, 'Vacation'] = df['Vacation'].mode()[0]

# Fill nan values with the mode
df['Time'] = df['Time'].fillna(df['Time'].mode()[0])
df['Time of day'] = df['Time of day'].fillna(df['Time of day'].mode()[0])
df['Date'] = df['Date'].fillna(df['Date'].mode()[0])
df['Day'] = df['Day'].fillna(df['Day'].mode()[0])
df['H&R Status'] = df['H&R Status'].fillna(df['H&R Status'].mode()[0])

# Printing Unique values in Day
print('After:', df['Day'].unique())


 #Displaying columns Tier and Severity values
print('Tier:', df['Tier'].unique())
print('Severity:', df['Severity'].unique())

# Display Severity Injury and Type of Road
display(df.loc[df['Severity'] == 'Injury'])

# Given that Injury is just in Category 2 with Unknown value, we drop columns
df = df.drop(['Tier','Severity'], axis=1)


# Displaying category columns 
print('Category 1:', df['Catogory1'].unique())
print('Category 2:', df['Catogory2'].unique())

# Replacing repeated labels
df.loc[df.Catogory1 == 'Self ', 'Catogory1'] = 'Self'
df.loc[df.Catogory1 == 'car', 'Catogory1'] = 'Car'
df.loc[df.Catogory1 == ' Scooter', 'Catogory1'] = 'Scooter'
df.loc[df.Catogory1 == 'jeep', 'Catogory1'] = 'Jeep'

# Displaying category columns 
print('\nCategory 1:', df['Catogory1'].unique())


import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

display(sns.pairplot(df[['Death', 'Injury', 'Total vehicle', 'Collision Type', 'Collision Spot']]))


category_label = ['Day','Time of Day', 'Vacation', 'H&R Status', 'Death', 'Injury', 'Total vehicle', 'Collision Type',
                  'Collision Spot', 'Type of Road', 'Divider', 'Catogory1', 'Catogory2']

fig, axes = plt.subplots(6, 2, figsize=(16,12))

#Commented on 31 Oct
#for ax, x in zip(axes.reshape(-1), category_label):
#    sns.countplot(x=x, data=df, ax=ax)

fig.tight_layout()


from patsy import dmatrices

#formula = 'Catogory2 ~ C(Time of Day) + C(Day) + C(Vacation) + C(Q("H&R Status")) + Death + Injury + Q("Total vehicle") + C(Q("Collision Type")) + C(Q("Collision Spot")) + C(Q("Type of Road")) + C(Divider) + C(Catogory1)'
formula = '''Catogory2 ~ C(Q("Time of day")) + C(Day) + C(Vacation) + C(Q("H&R Status")) + Death + Injury + Q("Total vehicle") + 
                         C(Q("Collision Type")) + C(Q("Collision Spot")) + C(Divider) + C(Catogory1)'''

# Preparing data for ML classifiers
_, X = dmatrices(formula, df, return_type='dataframe')
y = df['Catogory2']

# Dividing Unknown data
unk_data = X.loc[df['Catogory2'] == 'Unknown']
unk_label = y.loc[df['Catogory2'] == 'Unknown']
data = X.loc[df['Catogory2'] != 'Unknown']
label = y.loc[df['Catogory2'] != 'Unknown']

#data = df.loc[df['Catogory2'] != 'Unknown']
display(data.head())
display(label.head())
# scikit-learn k-fold cross-validation
from sklearn.model_selection import KFold

# prepare cross validation
#kfold = KFold(10, True, 7)
#data_splits = kfold.split(data)

#for train, dev in data_splits:
  # display(data.iloc[train].head())
  
  
from sklearn.model_selection import KFold
from sklearn.metrics import accuracy_score
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.gaussian_process.kernels import RBF
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from sklearn.linear_model import LogisticRegression
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis



import numpy as np
from collections import defaultdict


names = ["Nearest Neighbors", "Linear SVM", "RBF SVM", #"Gaussian Process",
         "Decision Tree", "Random Forest", "Neural Net", "AdaBoost",
         "Naive Bayes","LR","LDA","CART"]

classifiers = [
    KNeighborsClassifier(45),
    SVC(kernel="linear", gamma='auto'),
    SVC(kernel="rbf", gamma='auto'),
    #GaussianProcessClassifier(1.0 * RBF(1.0)),
    DecisionTreeClassifier(),
    RandomForestClassifier(n_estimators=1000),
    MLPClassifier(alpha=1),
    AdaBoostClassifier(),
    GaussianNB(),
    LogisticRegression(),
    LinearDiscriminantAnalysis(),
    GradientBoostingClassifier()]


accuracies = defaultdict(list)

# Prepare cross validation
kfold = KFold(5, True)
#kfold = KFold(10, True)
for train, dev in kfold.split(data):
    # Training data
    Xt = data.iloc[train]
    Yt = label.iloc[train]
    # Development data
    Xd = data.iloc[dev]
    Yd = label.iloc[dev]
    
    print('Training...')
    
    for name, clf in zip(names, classifiers):
        # Training
        clf.fit(Xt, Yt)
        # Predict
        Yp = clf.predict(Xd)
        accuracy = accuracy_score(Yd, Yp) * 100
        accuracies[name].append(accuracy)
        #print('Accuracy for {}: {}'.format(name, accuracy))

# Chosing best model
max_model = ''
max_value = 0
for key, value in accuracies.items():
    print('{}: {}'.format(key, sum(value) / len(value)))
    if sum(value) / len(value) > max_value:
        max_value = sum(value) / len(value)
        max_model = key
        
print('\nOur max accuracy was obtained by {}: {}'.format(max_model, max_value))



for name, clf in zip(names, classifiers):
    clf.fit(data, label)
    
u_data = unk_data[['Injury']].copy()

for name, clf in zip(names, classifiers):
    pred = clf.predict(unk_data)
    u_data[name] = pred
    
# Displaying new labels with models
display(u_data)


# Re-Loading data from Excel file
#df = pd.read_excel('1TierBH.xlsx')
#df = pd.read_excel('dataTierAM.xlsx')

#df = pd.read_excel('TierLU.xlsx')
#df = pd.read_excel('1TierAg.xlsx')
df = pd.read_excel('1TierVg.xlsx')
#df = pd.read_excel('TierVgMay2020.xlsx')


known_data = df.loc[df['Catogory2'] != 'Unknown'].copy()
unknown_data = df.loc[df['Catogory2'] == 'Unknown'].copy()

# Replacing Unknown values
unknown_data.drop(['Catogory2'], axis=1, inplace=True)
unknown_data['Catogory2'] = u_data[max_model]

new_df = pd.concat([known_data, unknown_data])
new_df.sort_index(inplace=True)

print('Before...')
display(df.groupby('Catogory2').count())
print('After... {}'.format(max_model))
display(new_df.groupby('Catogory2').count())

# Exporting to Excel
#new_df.to_excel("5F Vg May 2020output.xlsx", index=False)
#new_df.to_excel("31OctAGRA COLAB OUTPUT.xlsx", index=False)
new_df.to_excel("31OctVizag COLAB OUTPUT.xlsx", index=False)

